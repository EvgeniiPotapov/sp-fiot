/* ----------------------------------------------------------------------------------------------- */
/*   Copyright (c) 2014 - 2018 by Axel Kenzo, axelkenzo@mail.ru                                    */
/*   All rights reserved.                                                                          */
/*                                                                                                 */
/*  Разрешается повторное распространение и использование как в виде исходного кода, так и         */
/*  в двоичной форме, с изменениями или без, при соблюдении следующих условий:                     */
/*                                                                                                 */
/*   1. При повторном распространении исходного кода должно оставаться указанное выше уведомление  */
/*      об авторском праве, этот список условий и последующий отказ от гарантий.                   */
/*   2. При повторном распространении двоичного кода должна сохраняться указанная выше информация  */
/*      об авторском праве, этот список условий и последующий отказ от гарантий в документации     */
/*      и/или в других материалах, поставляемых при распространении.                               */
/*   3. Ни имя владельца авторских прав, ни имена его соратников не могут быть использованы в      */
/*      качестве рекламы или средства продвижения продуктов, основанных на этом ПО без             */
/*      предварительного письменного разрешения.                                                   */
/*                                                                                                 */
/*  ЭТА ПРОГРАММА ПРЕДОСТАВЛЕНА ВЛАДЕЛЬЦАМИ АВТОРСКИХ ПРАВ И/ИЛИ ДРУГИМИ СТОРОНАМИ "КАК ОНА ЕСТЬ"  */
/*  БЕЗ КАКОГО-ЛИБО ВИДА ГАРАНТИЙ, ВЫРАЖЕННЫХ ЯВНО ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ             */
/*  ОГРАНИЧИВАЯСЬ ИМИ, ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ КОММЕРЧЕСКОЙ ЦЕННОСТИ И ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ */
/*  ЦЕЛИ. НИ В КОЕМ СЛУЧАЕ НИ ОДИН ВЛАДЕЛЕЦ АВТОРСКИХ ПРАВ И НИ ОДНО ДРУГОЕ ЛИЦО, КОТОРОЕ МОЖЕТ    */
/*  ИЗМЕНЯТЬ И/ИЛИ ПОВТОРНО РАСПРОСТРАНЯТЬ ПРОГРАММУ, КАК БЫЛО СКАЗАНО ВЫШЕ, НЕ НЕСЁТ              */
/*  ОТВЕТСТВЕННОСТИ, ВКЛЮЧАЯ ЛЮБЫЕ ОБЩИЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ ИЛИ ПОСЛЕДОВАВШИЕ УБЫТКИ,         */
/*  ВСЛЕДСТВИЕ ИСПОЛЬЗОВАНИЯ ИЛИ НЕВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ ПРОГРАММЫ (ВКЛЮЧАЯ, НО НЕ             */
/*  ОГРАНИЧИВАЯСЬ ПОТЕРЕЙ ДАННЫХ, ИЛИ ДАННЫМИ, СТАВШИМИ НЕПРАВИЛЬНЫМИ, ИЛИ ПОТЕРЯМИ ПРИНЕСЕННЫМИ   */
/*  ИЗ-ЗА ВАС ИЛИ ТРЕТЬИХ ЛИЦ, ИЛИ ОТКАЗОМ ПРОГРАММЫ РАБОТАТЬ СОВМЕСТНО С ДРУГИМИ ПРОГРАММАМИ),    */
/*  ДАЖЕ ЕСЛИ ТАКОЙ ВЛАДЕЛЕЦ ИЛИ ДРУГОЕ ЛИЦО БЫЛИ ИЗВЕЩЕНЫ О ВОЗМОЖНОСТИ ТАКИХ УБЫТКОВ.            */
/*                                                                                                 */
/*   ak_log.c                                                                                      */
/* ----------------------------------------------------------------------------------------------- */
 #include <stdarg.h>
 #include <libakrypt.h>

/* ----------------------------------------------------------------------------------------------- */
#ifdef LIBAKRYPT_HAVE_SYSLOG_H
 #include <syslog.h>
#endif
#ifdef LIBAKRYPT_HAVE_UNISTD_H
 #include <unistd.h>
#endif
#ifdef LIBAKRYPT_HAVE_WINDOWS_H
 #include <windows.h>
#endif

/* ----------------------------------------------------------------------------------------------- */
/*!  Переменная, содержащая в себе код последней ошибки                                            */
 static int ak_errno = ak_error_ok;

/* ----------------------------------------------------------------------------------------------- */
/*! Внутренний указатель на функцию аудита                                                         */
 static ak_function_log *ak_function_log_default = NULL;
 static pthread_mutex_t ak_function_log_default_mutex = PTHREAD_MUTEX_INITIALIZER;

/* ----------------------------------------------------------------------------------------------- */
/*! \param value Код ошибки, который будет установлен. В случае, если значение value положительно,
    то код ошибки полагается равным величине \ref ak_error_ok (ноль).
    \return Функция возвращает устанавливаемое значение.                                           */
/* ----------------------------------------------------------------------------------------------- */
 int ak_error_set_value( const int value )
{
  return ( ak_errno = value );
}

/* ----------------------------------------------------------------------------------------------- */
/*! \return Функция возвращает текущее значение кода ошибки. Данное значение не является
    защищенным от возможности изменения различными потоками выполнения программы.                  */
/* ----------------------------------------------------------------------------------------------- */
 int ak_error_get_value( void )
{
  return ak_errno;
}

#ifdef LIBAKRYPT_HAVE_SYSLOG_H
/* ----------------------------------------------------------------------------------------------- */
/*! \param message Выводимое сообщение.
    \return В случае успеха, возвращается ak_error_ok (ноль). В случае возникновения ошибки,
    возвращается ее код.                                                                           */
/* ----------------------------------------------------------------------------------------------- */
 int ak_function_log_syslog( const char *message )
{
 #ifdef __linux__
   int priority = LOG_AUTHPRIV | LOG_NOTICE;
 #else
   int priority = LOG_USER;
 #endif
  if( message != NULL ) syslog( priority, "%s", message );
 return ak_error_ok;
}
#endif

/* ----------------------------------------------------------------------------------------------- */
/*! \param message Выводимое сообщение
    \return В случае успеха, возвращается ak_error_ok (ноль). В случае возникновения ошибки,
    возвращается ее код.                                                                           */
/* ----------------------------------------------------------------------------------------------- */
 int ak_function_log_stderr( const char *message )
{
  if( message != NULL ) fprintf( stderr, "%s\n", message );
 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! Функция устанавливает в качестве основного обработчика
    вывода сообщений функцию, задаваемую указателем function. Если аргумент function равен NULL,
    то используется функция по-умолчанию.
    Выбор того, какая именно функция будет установлена по-умолчанию, не фискирован.
    В текущей версии библиотеки он зависит от используемой операционной системы, например,
    под ОС Linux это вывод с использованием демона syslogd.

    \param function Указатель на функцию вывода сообщений.
    \return Функция всегда возвращает ak_error_ok (ноль).                                          */
/* ----------------------------------------------------------------------------------------------- */
 int ak_log_set_function( ak_function_log *function )
{
  pthread_mutex_lock( &ak_function_log_default_mutex );
  if( function != NULL ) ak_function_log_default = function;
   else {
    #ifdef LIBAKRYPT_HAVE_SYSLOG_H
      ak_function_log_default = ak_function_log_syslog;
    #else
      ak_function_log_default = ak_function_log_stderr;
    #endif
   }
  pthread_mutex_unlock( &ak_function_log_default_mutex );
  return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! Функция использует установленную ранее функцию-обработчик сообщений. Если сообщение,
    или обработчик не определены (равны NULL) возвращается код ошибки.
    \param message выводимое сообщение
    \return в случае успеха, возвращается ak_error_ok (ноль). В случае возникновения ошибки,
    возвращается ее код.                                                                           */
/* ----------------------------------------------------------------------------------------------- */
 int ak_log_set_message( const char *message )
{
  int result = 0;
  if( ak_function_log_default == NULL ) return ak_error_set_value( ak_error_undefined_function );
  if( message == NULL ) {
    return ak_error_message( ak_error_null_pointer, __func__ , "using a NULL string for message" );
  } else {
       pthread_mutex_lock( &ak_function_log_default_mutex );
       result = ak_function_log_default( message );
       pthread_mutex_unlock( &ak_function_log_default_mutex );
      return result;
    }
 return ak_error_ok;
}

/* ----------------------------------------------------------------------------------------------- */
/*! \param str Строка, в которую помещается результат (сообщение)
    \param size Максимальный размер помещаемого в строку str сообщения
    \param format Форматная строка, в соответствии с которой формируется сообщение

    \return Функция возвращает значение, которое вернул вызов системной (библиотечной) функции
    форматирования строки.                                                                         */
/* ----------------------------------------------------------------------------------------------- */
 int ak_snprintf( char *str, size_t size, const char *format, ... )
{
  int result = 0;
  va_list args;
  va_start( args, format );

 #ifdef _MSC_VER
  #if _MSC_VER > 1310
    result = _vsnprintf_s( str, size, size, format, args );
  #else
    result = _vsnprintf( str, size, format, args );
  #endif
 #else
  result = vsnprintf( str, size, format, args );
 #endif
  va_end( args );
 return result;
}

/* ----------------------------------------------------------------------------------------------- */
/*! Функция устанавливает текущее значение кода ошибки, формирует строку специального вида и
    выводит сформированную строку в логгер с помомощью функции ak_log_set_message().

    \param code Код ошибки
    \param message Читаемое (понятное для пользователя) сообщение
    \param function Имя функции, вызвавшей ошибку

    \return Функция возвращает установленный код ошибки.                                           */
/* ----------------------------------------------------------------------------------------------- */
 int ak_error_message( const int code, const char *function, const char *message )
{
 /* здесь мы выводим в логгер строку вида [pid] function: message (code: n)                        */
  char error_event_string[1024];
  memset( error_event_string, 0, 1024 );

#ifdef LIBAKRYPT_HAVE_UNISTD_H
  ak_snprintf( error_event_string, 1023, "[%d] %s(): %s (code: %d)",
                                                             getpid(), function, message, code );
#else
 #ifdef _MSC_VER
  ak_snprintf( error_event_string, 1023, "[%d] %s(): %s (code: %d)",
                                                GetCurrentProcessId(), function, message, code );
 #else
   #error Unsupported path to compile, sorry ...
 #endif
#endif
  ak_log_set_message( error_event_string );
 return ak_error_set_value( code );
}

/* ----------------------------------------------------------------------------------------------- */
/*! @param code Код ошибки
    @param function Имя функции, вызвавшей ошибку
    @param format Форматная строка, в соответствии с которой формируется сообщение                 */
/* ----------------------------------------------------------------------------------------------- */
 int ak_error_message_fmt( const int code, const char *function, const char *format, ... )
{
  char message[256];
  va_list args;
  va_start( args, format );
  memset( message, 0, 256 );

 #ifdef _MSC_VER
  #if _MSC_VER > 1310
    _vsnprintf_s( message, 256, 256, format, args );
  #else
    _vsnprintf( message, 256, format, args );
  #endif
 #else
   vsnprintf( message, 256, format, args );
 #endif
   va_end( args );
 return ak_error_message( code, function, message );
}

/* ----------------------------------------------------------------------------------------------- */
/*! \example example-log.c                                                                         */
/*! \example example-intro.c                                                                       */
/* ----------------------------------------------------------------------------------------------- */
/*                                                                                       ak_log.c  */
/* ----------------------------------------------------------------------------------------------- */
