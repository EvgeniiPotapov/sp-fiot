<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libakrypt: Принципы реализации</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libakrypt
   &#160;<span id="projectnumber">Версия 0.6.7</span>
   </div>
   <div id="projectbrief">Модуль, реализующий криптографические преобразования для проекта OpenSKZI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li class="current"><a href="pages.html"><span>Описания</span></a></li>
      <li><a href="annotated.html"><span>Структуры&#160;данных</span></a></li>
      <li><a href="files.html"><span>Файлы</span></a></li>
      <li><a href="examples.html"><span>Примеры</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('guide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Принципы реализации </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Библиотека <code>libakrypt</code> реализует два уровня интерфейсов к криптографическим преобразованиям. Первый уровень - внешний интерфейс, предоставляемый файлом <a class="el" href="libakrypt_8h.html">libakrypt.h</a>, был рассмотрен в главе <a class="el" href="libex.html">Инструкция по встраиванию</a>. Напомним, что именно внешний интерфейс должен использоваться прикладным программным обеспечением для доступа к криптографческим механизмам, реализуемым библиотекой.</p>
<p>В этой главе мы рассмотрим внутренний интерфейс библиотеки, доступ к которому ограничен по соображениям безопасности. Мы также опишем принципы реализации основных функциональных возможностей библиотеки и приведем примеры использования и модификации функций библиотеки.</p>
<h1><a class="anchor" id="guide_hash"></a>
Алгоритмы бесключевого хеширования</h1>
<p>Для создания единообразного подхода к реализации алгоритмов бесключевого хеширования в библиотеке определяется структура <a class="el" href="structhash.html">hash</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ak__hash_8h.html">ak_hash.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="structhash.html">hash</a> {</div><div class="line">  <span class="keywordtype">size_t</span> <a class="code" href="structhash.html#a2cbae7e4bd552155acfe6bd81683e50f">bsize</a>; <span class="comment">// размер обрабатываемого блока входных данных</span></div><div class="line">  <span class="keywordtype">size_t</span> <a class="code" href="structhash.html#a60efd2ffbea463b6be440d330d6c0b7f">hsize</a>; <span class="comment">//  размер выходного блока</span></div><div class="line">  <a class="code" href="libakrypt_8h.html#a59817f4698b8d80ec2f6ef2af4111190">ak_pointer</a> <a class="code" href="structhash.html#a0d9dd0697d4bd775e4f48135a8d9dad8">data</a>; <span class="comment">// указатель на внутренние данные контекста</span></div><div class="line">  <a class="code" href="structoid.html">ak_oid</a> <a class="code" href="structhash.html#a7f4ba87673ab3865e1cc7e16019afe69">oid</a>;   <span class="comment">// OID алгоритма хеширования</span></div><div class="line"></div><div class="line">  <a class="code" href="ak__hash_8h.html#a77a2623949cf90dd5c9b4952776d92c7">ak_function_mac_clean</a> *<a class="code" href="structhash.html#a25a4b740eb7a5bf0d591ab6bd709aaed">clean</a>; <span class="comment">// функция очистки контекста</span></div><div class="line">  <a class="code" href="ak__hash_8h.html#a390f5248a64bca9090c3dbe7cea77d93">ak_function_mac_update</a> *<a class="code" href="structhash.html#abef332a620e87fc9a1f0c11afe144112">update</a>; <span class="comment">// функция обновления состояния контекста</span></div><div class="line">  <a class="code" href="ak__hash_8h.html#a03d881dc0415fda3ef5f29156dda459d">ak_function_mac_finalize</a> *<a class="code" href="structhash.html#a1dfe3612fc851f46bdd793b551ce7155">finalize</a>; <span class="comment">// функция получения конечного результата</span></div><div class="line">};</div></div><!-- fragment --><p>Структура описывает данные, необходимые для корректной работы, а также три указателя на функции. После инициализации объекта данной структуры значения указателей содержат ссылки на конкретный алгоритм бесключевого хеширования.</p>
<p>Объекты struct <a class="el" href="structhash.html">hash</a> должны инициализироваться с помощью производящих функций, см. <a class="el" href="ak__hash_8h.html">ak_hash.h</a>, в частности следующих </p><ul>
<li>int <a class="el" href="ak__gosthash_8c.html#a8821cbb8ca829cd670b98c8fe95e2e78" title="Инициализация контекста функции бесключевого хеширования ГОСТ Р 34.11-94. ">ak_hash_create_gosthash94()</a>; </li>
<li>int <a class="el" href="ak__gosthash_8c.html#ac794c88be60a9dcd4fc595bdb1e990f0" title="Инициализация контекста функции бесключевого хеширования ГОСТ Р 34.11-94 с таблицами замен из RFC 435...">ak_hash_create_gosthash94_csp()</a>; </li>
<li>int <a class="el" href="ak__hash_8h.html#a4577946909e39956e2d41fcc408a53b5" title="Инициализация контекста функции бесключевого хеширования ГОСТ Р 34.11-2012 (Стрибог256). ">ak_hash_create_streebog256()</a>; </li>
<li>int <a class="el" href="ak__hash_8h.html#a7ed6e2c852160fb48ef9fac46b91bcd2" title="Инициализация контекста функции бесключевого хеширования ГОСТ Р 34.11-2012 (Стрибог512). ">ak_hash_create_streebog512()</a>; </li>
<li>int <a class="el" href="ak__hash_8c.html#acc96fd8cfa8b1436adba40235509a4a3" title="Инициализация контекста функции бесключевого хеширования по заданному OID алгоритма. ">ak_hash_create_oid()</a>.</li>
</ul>
<p>Каждая из указанных функций определяет значения полей объекта struct <a class="el" href="structhash.html">hash</a> в соответствии с тем алгоритмом, который содержится в ее названии. При этом инициализируются указатели на три определенные функции: функцию очистки (<code>clean</code>), функцию обновления внутреннего состояния (<code>update</code>) и функцию возврата результата вычислений (<code>finalize</code>).</p>
<p>При этом предполагается, что действие <code>update</code> может обрабатывать только данные, длина которых в байтах кратна длине блока обрабатываемых данных, см. поле <code>bsize</code> (данное значение жестко фиксируется при описании алгоритма). Такое поведение в точности соответствует подходу, принятому при математическом описании алгоритмов бесключевого хеширования. Вопросами обработки данных произвольной длины занимается класс <a class="el" href="structcompress.html">compress</a>.</p>
<p>Более того, вызов функции <code>fimalize</code> не изменяет внутреннее состояние и производит вычисления с локальной копией текущего состояния. Такой подход позволяет вычислять хеш-код не только для всей последовательности данных, но и для ее фрагментов.</p>
<p>Внутреннее состояние алгоритма бесключевого хеширования <a class="el" href="structhash.html">hash</a> может описываться произвольной структурой данных. Данная структура должна определяться в конкретной реализации алгоритма хеширования, создаваться в динамической памяти при вызове производящей функции, а указатель на структуру должен помещаться в поле <code>data</code> (использование одной статически выделенной структуры для нескольких объектов может привести к неверным результатам).</p>
<p>В текущей реализации билиотеки используются следующие структуры, описывающие внутренние состояния </p><ul>
<li>struct <a class="el" href="structgosthash94.html">gosthash94</a> (для алгоритма из ГОСТ Р 34.11-94), </li>
<li>struct <a class="el" href="structstreebog.html">streebog</a> (для двух алгоритмов из ГОСТ Р 34.11-2012).</li>
</ul>
<p>Уничтожение созданного ранее объекта производится с помощью функции <a class="el" href="ak__hash_8c.html#aea4a84bb72d71f441657796db70a0d99" title="Уничтожение контекста функции хеширования. ">ak_hash_destroy()</a>, которая не только обнуляет все значения, но и освобождает память из под структуры с внутренним состоянием.</p>
<h2><a class="anchor" id="guide_hash_create"></a>
Создание, использование и удаление объектов</h2>
<p>Общая схема использования объектов struct <a class="el" href="structhash.html">hash</a> заключается в следующем.</p>
<ol type="1">
<li>Определить объект (переменную типа struct <a class="el" href="structhash.html">hash</a>) в статической или динамической памяти (с использованием функции malloc()).</li>
<li>Инициализировать объект класса путем вызова соответствующей производящей функции, список см. выше.</li>
<li>Выработать хеш-код (код целостности) от заданной области памяти или заданного файла.</li>
<li>Уничтожить объект класса путем вызова функции <a class="el" href="ak__hash_8c.html#aea4a84bb72d71f441657796db70a0d99" title="Уничтожение контекста функции хеширования. ">ak_hash_destroy()</a>. Если объект был создан в динамической памяти, то для уничтожения необходимо использовать функцию <a class="el" href="ak__hash_8c.html#aa5a836acf3ccc00be158a4837476cfaf" title="Освобождение памяти из под контекста функции хеширования. ">ak_hash_delete()</a>.</li>
</ol>
<p>Следующий пример (<a class="el" href="example-internal-hash01_8c-example.html">example-internal-hash01.c</a>) демонстрирует процесс создания, удаления и использования объектов типа struct <a class="el" href="structhash.html">hash</a>.</p>
<div class="fragment"><div class="line"><span class="comment">/* ----------------------------------------------------------------------------------------------- *</span></div><div class="line"><span class="comment">   Пример, иллюстрирующий создание, удаление контекстов функции хеширования,</span></div><div class="line"><span class="comment">   а также вычисление хеш-кода для данных с известной длиной.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   Внимание: используются неэкспортируемые функции библиотеки</span></div><div class="line"><span class="comment"> * ----------------------------------------------------------------------------------------------- */</span></div><div class="line"><span class="preprocessor"> #include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor"> #include &lt;<a class="code" href="ak__hash_8h.html">ak_hash.h</a>&gt;</span></div><div class="line"></div><div class="line"> <span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div><div class="line">{</div><div class="line"> <span class="keywordtype">char</span> *str = NULL;</div><div class="line"> <span class="keyword">struct </span><a class="code" href="structhash.html">hash</a> ctx_one;    <span class="comment">/* объект, размещаемый в статической памяти (стеке) */</span></div><div class="line"> <a class="code" href="structhash.html">ak_hash</a> ctx_two = NULL; <span class="comment">/* объект, размещаемый в динамической памяти (куче) */</span></div><div class="line"> <a class="code" href="structbuffer.html">ak_buffer</a> result_one = NULL; <span class="comment">/* результат вычислений, помещаемый в кучу */</span></div><div class="line"> <a class="code" href="libakrypt_8h.html#abb8a94ec74dcd719f5e85ecbae89cb68">ak_uint8</a> result_two[64]; <span class="comment">/* результат вычислений, помещаемый в стек */</span></div><div class="line"> <a class="code" href="libakrypt_8h.html#abb8a94ec74dcd719f5e85ecbae89cb68">ak_uint8</a> some_pointer[7] = { 0, 1, 2, 3, 4, 5, 6 }; <span class="comment">/* данные для хеширования */</span></div><div class="line"></div><div class="line"> <span class="comment">/* статический объект уже создан, он требует инициализации</span></div><div class="line"><span class="comment">    создаем объект в динамической памяти */</span></div><div class="line">  ctx_two = malloc( <span class="keyword">sizeof</span>( <span class="keyword">struct</span> <a class="code" href="structhash.html">hash</a> ));</div><div class="line"></div><div class="line"> <span class="comment">/* инициализируем статический объект */</span></div><div class="line">  <a class="code" href="ak__hash_8h.html#a4577946909e39956e2d41fcc408a53b5">ak_hash_create_streebog256</a>( &amp;ctx_one );</div><div class="line"> <span class="comment">/* инициализируем динамический объект */</span></div><div class="line">  <a class="code" href="ak__hash_8h.html#a7ed6e2c852160fb48ef9fac46b91bcd2">ak_hash_create_streebog512</a>( ctx_two );</div><div class="line"></div><div class="line"> <span class="comment">/* вычисляем хеш-код от заданной области памяти */</span></div><div class="line">  result_one =</div><div class="line">    <a class="code" href="ak__hash_8c.html#ac75d2cff768ede84507e4e809f0b6cf7">ak_hash_context_ptr</a>( &amp;ctx_one, some_pointer, <span class="keyword">sizeof</span>( some_pointer ), NULL );</div><div class="line">  printf(<span class="stringliteral">&quot;hash [1]: %s\n&quot;</span>, str = <a class="code" href="ak__buffer_8c.html#a55623f2c794de6339511e9c177327d33">ak_buffer_to_hexstr</a>( result_one, <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a872df325c5f9fac16ef66c17c1666908">ak_false</a> ));</div><div class="line"></div><div class="line"> <span class="comment">/* освобождаем память */</span></div><div class="line">  result_one = <a class="code" href="ak__buffer_8c.html#a8211931355126eeb16e6b8d6ed7ba187">ak_buffer_delete</a>( result_one ); free( str );</div><div class="line"></div><div class="line"> <span class="comment">/* вычисляем хеш-код от заданного файла */</span></div><div class="line">  <a class="code" href="ak__hash_8c.html#a1075b28b341a31642639697771a244dd">ak_hash_context_file</a>( ctx_two, <span class="stringliteral">&quot;some.filename&quot;</span>, result_two );</div><div class="line"> <span class="comment">/* поскольку файл some.filename не существует, будет возбуждена ошибка */</span></div><div class="line">  printf(<span class="stringliteral">&quot;hash [2]: %d\n&quot;</span>, <a class="code" href="ak__log_8c.html#aa0cdd429c558ca0448ce3a8e9529e920">ak_error_get_value</a>());</div><div class="line"></div><div class="line">  <a class="code" href="ak__hash_8c.html#aea4a84bb72d71f441657796db70a0d99">ak_hash_destroy</a>( &amp;ctx_one ); <span class="comment">// уничтожение объекта</span></div><div class="line">  ctx_two  = <a class="code" href="ak__hash_8c.html#aa5a836acf3ccc00be158a4837476cfaf">ak_hash_delete</a>( ctx_two ); <span class="comment">// уничтожение объекта</span></div><div class="line">                                       <span class="comment">// и освобождение выделенной под него памяти</span></div><div class="line"> <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* ----------------------------------------------------------------------------------------------- */</span></div></div><!-- fragment --><h2><a class="anchor" id="guide_hash_data"></a>
Хеширование данных</h2>
<p>Существует два типа ситуаций, в которых требуется вычисление значений функций бесключевого хеширования. В первой ситуации размер данных, подлежащих хешированию, известен заранее. В этом случае библиотека предоставляет две функции внутреннего интерфеса, а именно,</p>
<ul>
<li><a class="el" href="ak__hash_8c.html#ac75d2cff768ede84507e4e809f0b6cf7" title="Хеширование заданной области памяти. ">ak_hash_context_ptr()</a> - вычисление значения функции бесключевого хеширования для данных с фиксированной длиной; алгоритм хеширования определяется указателем на объект struct <a class="el" href="structhash.html">hash</a>, который передается в качестве первого аргумента функции;</li>
</ul>
<ul>
<li><a class="el" href="ak__hash_8c.html#a1075b28b341a31642639697771a244dd" title="Хеширование заданного файла. ">ak_hash_context_file()</a> - вычисление значения функции бесключевого хеширования для заданного файла.</li>
</ul>
<p>Пример использования указанных функций приведен выше (см. файл <a class="el" href="example-internal-hash01_8c-example.html">example-internal-hash01.c</a>).</p>
<p>Во второй ситуации окончательная длина данных неизвестна, поэтому обработка может вестись фрагментами, длина которых совпадает (или кратна) длине блока обрабатываемых данных. В этом случае, для каждого фрагмента данных должна вызываться функция <code>update</code>, изменяющая внутреннее состояние объекта. При завершении вычислений должна вызываться функция <code>finalize</code>, на вход которой также могут подаваться хешируемые данные. При этом длина данных, подаваемых на вход функции <code>finalize</code> может быть равна нулю и не должна превышать длины блока обрабатываемых данных.</p>
<p>Пример последовательного использования обеих подходов приводится в следующем примере (см. файл <a class="el" href="example-internal-hash02_8c-example.html">example-internal-hash02.c</a>)</p>
<div class="fragment"><div class="line"><span class="comment">/* ----------------------------------------------------------------------------------------------- *</span></div><div class="line"><span class="comment">   Пример, иллюстрирующий вычисление хеш-кода от данных,</span></div><div class="line"><span class="comment">   обрабатываемых фрагментами фиксированной длины</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   Внимание: используются неэкспортируемые функции библиотеки</span></div><div class="line"><span class="comment"> * ----------------------------------------------------------------------------------------------- */</span></div><div class="line"><span class="preprocessor"> #include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor"> #include &lt;<a class="code" href="ak__hash_8h.html">ak_hash.h</a>&gt;</span></div><div class="line"><span class="preprocessor"> #include &lt;<a class="code" href="ak__random_8h.html">ak_random.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">/* ----------------------------------------------------------------------------------------------- */</span></div><div class="line"> <span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div><div class="line">{</div><div class="line"> <span class="keyword">struct </span><a class="code" href="structhash.html">hash</a> ctx;</div><div class="line"> <span class="keyword">struct </span><a class="code" href="structrandom.html">random</a> generator;</div><div class="line"> <span class="keywordtype">int</span> i = 0, result = <a class="code" href="libakrypt_8h.html#aa6db0eccf8222376f61f2f033a1bbe4c">ak_error_ok</a>;</div><div class="line"> <a class="code" href="libakrypt_8h.html#abb8a94ec74dcd719f5e85ecbae89cb68">ak_uint8</a> <a class="code" href="structrandom.html#a0d9dd0697d4bd775e4f48135a8d9dad8">data</a>[512], out[8][32], res[32], message[128];</div><div class="line"></div><div class="line"> <span class="comment">/* 1. инициализируем библиотеку с выводом сообщений в стандартный поток вывода ошибок */</span></div><div class="line">  <span class="keywordflow">if</span>( <a class="code" href="ak__libakrypt_8c.html#abd613394f9e581b93407381a15751200">ak_libakrypt_create</a>( <a class="code" href="ak__log_8c.html#a6b9332de8025dac9ac816bf2f303d39c">ak_function_log_stderr</a> ) != <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a76821fa33e47cc8cbc32aecf832da9c0">ak_true</a> ) <span class="keywordflow">return</span> <a class="code" href="ak__libakrypt_8c.html#a7b2010bf04cdfa2e9575dbe570de71cb">ak_libakrypt_destroy</a>();</div><div class="line"></div><div class="line"> <span class="comment">/* 2. вырабатываем массив случайных данных */</span></div><div class="line">   <a class="code" href="ak__random_8c.html#a7591cdc413cb73da8b1eb463aebc2530">ak_random_create_lcg</a>( &amp;generator );</div><div class="line">   generator.random( &amp;generator, data, <span class="keyword">sizeof</span>( data ));</div><div class="line">   <a class="code" href="ak__random_8c.html#a6a4676e2f5acb44c1023dc640f271448">ak_random_destroy</a>( &amp;generator ); <span class="comment">/* освобождаем генератор, поскольку он больше не нужен */</span></div><div class="line"></div><div class="line"> <span class="comment">/* 3. вычисляем значение хеш-кода */</span></div><div class="line">   printf(<span class="stringliteral">&quot;the first experiment:\n&quot;</span>);</div><div class="line">   <a class="code" href="ak__hash_8h.html#a4577946909e39956e2d41fcc408a53b5">ak_hash_create_streebog256</a>( &amp;ctx ); <span class="comment">/* создаем контекст */</span></div><div class="line">   <span class="keywordflow">for</span>( i = 0; i &lt; <span class="keyword">sizeof</span>(<a class="code" href="structrandom.html#a0d9dd0697d4bd775e4f48135a8d9dad8">data</a>)/ctx.bsize; i++ ) {</div><div class="line">     <span class="comment">/* изменяем внутреннее состояние, при этом</span></div><div class="line"><span class="comment">        для изменения внутреннего состояния используем фрагмент данных,</span></div><div class="line"><span class="comment">        длина которых равна длине блока */</span></div><div class="line">      ctx.update( &amp;ctx, data+ctx.bsize*i, ctx.bsize );</div><div class="line"></div><div class="line">     <span class="comment">/* вычисляем значение хеш-кода для обработанной последовательности фрагментов;</span></div><div class="line"><span class="comment">        при финализации учитываем, что данные кратны длине блока,</span></div><div class="line"><span class="comment">        поэтому finalize не принимает данные для обработки */</span></div><div class="line">      ctx.finalize( &amp;ctx, NULL, 0, out[i] );</div><div class="line"></div><div class="line">     <span class="comment">/* выводим результат */</span></div><div class="line">      <a class="code" href="ak__tools_8c.html#a20fa595a38b20425248b6fe4d6faa069">ak_ptr_to_hexstr_static</a>( out[i], 32, message, 128, <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a872df325c5f9fac16ef66c17c1666908">ak_false</a> );</div><div class="line">      printf(<span class="stringliteral">&quot;hash[%d]: %s\n&quot;</span>, i, message );</div><div class="line">   }</div><div class="line">   <a class="code" href="ak__hash_8c.html#aea4a84bb72d71f441657796db70a0d99">ak_hash_destroy</a>( &amp;ctx );</div><div class="line"></div><div class="line"> <span class="comment">/* 4. вычисляем ту же последовательность хеш-кодов,</span></div><div class="line"><span class="comment">       но теперь для фрагментов с известной длины */</span></div><div class="line">   printf(<span class="stringliteral">&quot;\nthe second experiment:\n&quot;</span>);</div><div class="line">   <a class="code" href="ak__hash_8h.html#a4577946909e39956e2d41fcc408a53b5">ak_hash_create_streebog256</a>( &amp;ctx );</div><div class="line">   <span class="keywordflow">for</span>( i = 0; i &lt; <span class="keyword">sizeof</span>(<a class="code" href="structrandom.html#a0d9dd0697d4bd775e4f48135a8d9dad8">data</a>)/ctx.bsize; i++ ) {</div><div class="line">     <span class="comment">/* вычисляем хеш-код от начала сообщения (фрагмент известной длины) */</span></div><div class="line">      <a class="code" href="ak__hash_8c.html#ac75d2cff768ede84507e4e809f0b6cf7">ak_hash_context_ptr</a>( &amp;ctx, data, ctx.bsize*(i+1), res );</div><div class="line"></div><div class="line">     <span class="comment">/* выводим результат */</span></div><div class="line">      <a class="code" href="ak__tools_8c.html#a20fa595a38b20425248b6fe4d6faa069">ak_ptr_to_hexstr_static</a>( res, 32, message, 128, <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a872df325c5f9fac16ef66c17c1666908">ak_false</a> );</div><div class="line">      printf(<span class="stringliteral">&quot;hash[%d]: %s\n&quot;</span>, i, message );</div><div class="line"></div><div class="line">     <span class="comment">/* сравниваем новое значение с вычисленным ранее</span></div><div class="line"><span class="comment">        при различных результатах меняем возвращаемый результат */</span></div><div class="line">      <span class="keywordflow">if</span>( !<a class="code" href="ak__tools_8c.html#aad0f57a8872509185b031a4dca334f98">ak_ptr_is_equal</a>( out[i], res, 32 )) result = <a class="code" href="libakrypt_8h.html#ad069bfba9bc6325246fd639d86dd8e51">ak_error_not_equal_data</a>;</div><div class="line">   }</div><div class="line">   <a class="code" href="ak__hash_8c.html#aea4a84bb72d71f441657796db70a0d99">ak_hash_destroy</a>( &amp;ctx );</div><div class="line"> <span class="comment">/* завершаем работу с библиотекой */</span></div><div class="line">  <a class="code" href="ak__libakrypt_8c.html#a7b2010bf04cdfa2e9575dbe570de71cb">ak_libakrypt_destroy</a>();</div><div class="line"></div><div class="line"> <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>В случае, когда необходимо определить хеш-код данных, которые поступают на обработку фрагментами произвольной длины, необходимо воспользоваться методами класса <a class="el" href="structcompress.html">compress</a>. Данный класс специально разработан для этой цели.</p>
<p>Еще один работающий пример, иллюстрирующий множество различных подходов к вычислению кодов целостности для файлов, может быть найден в файле <a class="el" href="example-internal-hash03_8c-example.html">example-internal-hash03.c</a></p>
<h1><a class="anchor" id="guide_mac"></a>
Алгоритмы выработки имитовставки</h1>
<h1><a class="anchor" id="guide_compress"></a>
Механизм итерационного сжатия информации</h1>
<p>В случае, когда сжимаемая информация не может быть представлена в виде фрагментов фиксированной длины, для ее обработки может использоваться класс, определяемый структурой <a class="el" href="structcompress.html">compress</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor"> #include &lt;<a class="code" href="ak__compress_8h.html">ak_compress.h</a>&gt;</span></div><div class="line"></div><div class="line"> <span class="keyword">struct </span><a class="code" href="structcompress.html">compress</a></div><div class="line">{</div><div class="line"></div><div class="line">  <a class="code" href="libakrypt_8h.html#abb8a94ec74dcd719f5e85ecbae89cb68">ak_uint8</a> *<a class="code" href="structcompress.html#ad0778c378c25c283f941383eea497d6f">data</a>; <span class="comment">// массив, предназначенный для временного хранения обрабатываемых данных</span></div><div class="line">  <span class="keywordtype">size_t</span> <a class="code" href="structcompress.html#a2cbae7e4bd552155acfe6bd81683e50f">bsize</a>;   <span class="comment">// длина блока обрабатываемых данных</span></div><div class="line">  <span class="keywordtype">size_t</span> <a class="code" href="structcompress.html#a60efd2ffbea463b6be440d330d6c0b7f">hsize</a>;   <span class="comment">// длина хеш-кода (результата применения сжимающего отображения)</span></div><div class="line">  <span class="keywordtype">size_t</span> <a class="code" href="structcompress.html#ae809d5359ac030c60a30a8f0b2294b82">length</a>;  <span class="comment">// количество элементов, хранящихся в массиве data</span></div><div class="line">  <a class="code" href="libakrypt_8h.html#a59817f4698b8d80ec2f6ef2af4111190">ak_pointer</a> <a class="code" href="structcompress.html#a38b0408fc77ca676c794ef9ef33622fa">ctx</a>; <span class="comment">// указатель на контекст сжимающего преобразования</span></div><div class="line">  <a class="code" href="ak__hash_8h.html#a77a2623949cf90dd5c9b4952776d92c7">ak_function_mac_clean</a> *<a class="code" href="structcompress.html#a25a4b740eb7a5bf0d591ab6bd709aaed">clean</a>; <span class="comment">// функция очистки контекста сжимающего</span></div><div class="line">                                <span class="comment">// преобразования</span></div><div class="line">  <a class="code" href="ak__hash_8h.html#a390f5248a64bca9090c3dbe7cea77d93">ak_function_mac_update</a> *<a class="code" href="structcompress.html#abef332a620e87fc9a1f0c11afe144112">update</a>; <span class="comment">// функция обработки данных, длина которых</span></div><div class="line">                                  <span class="comment">// кратна длине обрабатываемого блока</span></div><div class="line">  <a class="code" href="ak__hash_8h.html#a03d881dc0415fda3ef5f29156dda459d">ak_function_mac_finalize</a> *<a class="code" href="structcompress.html#a1dfe3612fc851f46bdd793b551ce7155">finalize</a>; <span class="comment">// функция завершения сжимающего</span></div><div class="line">                                      <span class="comment">// преобразования</span></div><div class="line">};</div></div><!-- fragment --><p>Данная структура реализует буфер, в котором накапливаются данные перед тем, как быть переданными на обработку. Общая схема использования объектов класса <a class="el" href="structcompress.html">compress</a> заключается в следующем.</p>
<ol type="1">
<li>Определить объект (переменную типа struct <a class="el" href="structcompress.html">compress</a>) в статической или динамической памяти (с использованием функции malloc()).</li>
<li><p class="startli">Инициализировать объект класса путем вызова соответствующей производящей функции. В качестве производящих функций, на настоящий момент, реализованы следующие.</p>
<ul>
<li>функция int <a class="el" href="ak__compress_8c.html#a2c8157efba25b0066270c3cd0b6e7822" title="Инициализация контекста сжимающего отображения, реализуемого при помощи бесключевой функции хеширован...">ak_compress_create_hash()</a> для вычислений код целостности (бесключевых функций хеширования), </li>
<li>функция int <a class="el" href="ak__compress_8c.html#ac784c761a1c90549b6a354ef3a1a66a4" title="Инициализация контекста сжимающего отображения, реализуемого при помощи ключевой функции хеширования...">ak_compress_create_mac()</a> для вычисления значений имитовставок.</li>
</ul>
</li>
<li>В случае, если используется ключевое преобразование, установить секретный ключ.</li>
<li>Выработать результат сжимающего преобразования (код целостности или имитовставку) от последовательности фрагментов произвольной длины.</li>
<li>Уничтожить объект класса путем вызова функции <a class="el" href="ak__compress_8c.html#a1a2220fdaff8ccc3661a9e5d067cc02f" title="Уничтожение контекста сжимающего отображения. ">ak_compress_destroy()</a>. Если объект был создан в динамической памяти, то для его уничтожения необходимо использовать функцию <a class="el" href="ak__compress_8h.html#aac5e65b7920f9cd414cd136c541c4301" title="Освобождение памяти из под контекста сжимающего отображения. ">ak_compress_delete()</a>.</li>
</ol>
<p>Коротко рассмотрим способы применения объектов класса <a class="el" href="structcompress.html">compress</a> для вычисления различных сжимающих преобразований.</p>
<h2><a class="anchor" id="guide_compress_hash"></a>
Хеширование данных</h2>
<p>Для хеширования данных необходимо сначала создать и инициализировать объект класса <a class="el" href="structhash.html">hash</a>. После этого, инициализировать объект класса <a class="el" href="structcompress.html">compress</a> и провести вычисления. Пример такого подхода иллюстрирует следующий тестовый пример (см. файл <a class="el" href="example-internal-compress01_8c-example.html">example-internal-compress01.c</a>)</p>
<div class="fragment"><div class="line"><span class="comment">/* ----------------------------------------------------------------------------------------------- *</span></div><div class="line"><span class="comment">   Тестовый пример, иллюстрирующий возможность использования класса compress для</span></div><div class="line"><span class="comment">   вычисления значения бесключевой функции хеширования</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   Внимание: используются неэкспортируемые функции библиотеки</span></div><div class="line"><span class="comment"> * ----------------------------------------------------------------------------------------------- */</span></div><div class="line"><span class="preprocessor"> #include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor"> #include &lt;<a class="code" href="ak__compress_8h.html">ak_compress.h</a>&gt;</span></div><div class="line"></div><div class="line"> <span class="keywordtype">int</span> main( <span class="keywordtype">void</span> )</div><div class="line">{</div><div class="line">  <span class="keywordtype">char</span> *str = NULL;</div><div class="line">  <span class="keywordtype">size_t</span> offset = 0;</div><div class="line">  <span class="keywordtype">int</span> result = <a class="code" href="libakrypt_8h.html#aa6db0eccf8222376f61f2f033a1bbe4c">ak_error_ok</a>;</div><div class="line">  <a class="code" href="libakrypt_8h.html#abb8a94ec74dcd719f5e85ecbae89cb68">ak_uint8</a> data[65536]; <span class="comment">/* данные для хеширования */</span></div><div class="line">  <span class="keyword">struct </span><a class="code" href="structhash.html">hash</a> ctx; <span class="comment">/* объект бесключевого хеширования */</span></div><div class="line">  <span class="keyword">struct </span><a class="code" href="structcompress.html">compress</a> comp ; <span class="comment">/* объект итеративного сжатия */</span></div><div class="line">  <a class="code" href="libakrypt_8h.html#abb8a94ec74dcd719f5e85ecbae89cb68">ak_uint8</a> out[32], out2[32]; <span class="comment">/* массивы для хранения результата вычислений */</span></div><div class="line"></div><div class="line"> <span class="comment">/* создаем данные для хеширования */</span></div><div class="line">  memset( data, 0, 65536 ); data[1] = 0x11; data[65534] = 0x12;</div><div class="line"></div><div class="line"> <span class="comment">/* инициализируем библиотеку */</span></div><div class="line">  <span class="keywordflow">if</span>( !<a class="code" href="ak__libakrypt_8c.html#abd613394f9e581b93407381a15751200">ak_libakrypt_create</a>( NULL )) <span class="keywordflow">return</span> <a class="code" href="ak__libakrypt_8c.html#a7b2010bf04cdfa2e9575dbe570de71cb">ak_libakrypt_destroy</a>();</div><div class="line"></div><div class="line"> <span class="comment">/* сперва хешируем данные (при известной длине) */</span></div><div class="line">  <a class="code" href="ak__gosthash_8c.html#ac794c88be60a9dcd4fc595bdb1e990f0">ak_hash_create_gosthash94_csp</a>( &amp;<a class="code" href="structcompress.html#a38b0408fc77ca676c794ef9ef33622fa">ctx</a> ); <span class="comment">/* старый алгоритм хеширвоания с фиксированными таблицами */</span></div><div class="line">  <a class="code" href="ak__hash_8c.html#ac75d2cff768ede84507e4e809f0b6cf7">ak_hash_context_ptr</a>( &amp;<a class="code" href="structcompress.html#a38b0408fc77ca676c794ef9ef33622fa">ctx</a>, data, 65536, out ); <span class="comment">/* хешируем данные */</span></div><div class="line">  printf(<span class="stringliteral">&quot;hash: %s\n&quot;</span>, str = <a class="code" href="ak__tools_8c.html#a2975dac532a6f245813cde9a2d3a9909">ak_ptr_to_hexstr</a>( out, 32, <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a872df325c5f9fac16ef66c17c1666908">ak_false</a> )); free( str );</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">/* теперь хешируем через итеративное сжатие */</span></div><div class="line"></div><div class="line">  <a class="code" href="structcompress.html#a38b0408fc77ca676c794ef9ef33622fa">ctx</a>.clean( &amp;<a class="code" href="structcompress.html#a38b0408fc77ca676c794ef9ef33622fa">ctx</a> ); <span class="comment">/* очищаем объект от предыдущего мусора */</span></div><div class="line">  <a class="code" href="ak__compress_8c.html#a2c8157efba25b0066270c3cd0b6e7822">ak_compress_create_hash</a>( &amp;comp, &amp;<a class="code" href="structcompress.html#a38b0408fc77ca676c794ef9ef33622fa">ctx</a> ); <span class="comment">/* инициализируем</span></div><div class="line"><span class="comment">        контекст итерационного сжатия путем указания ссылки</span></div><div class="line"><span class="comment">                          на объект бесключевого хеширования */</span></div><div class="line"></div><div class="line"> <span class="comment">/* теперь обрабатываем данные последовательными фрагментами случайной длины */</span></div><div class="line">  <span class="keywordflow">while</span>( offset &lt; 65536 ) {</div><div class="line">    <span class="keywordtype">size_t</span> len = rand()%256; <span class="comment">/* используем стандартный генератор ПСЧ */</span></div><div class="line">    <span class="keywordflow">if</span>( offset + len &gt;= 65536 ) len = 65536 - offset;</div><div class="line">    <a class="code" href="ak__compress_8c.html#af4e2eb8ba9cbcce1314b55811f442634">ak_compress_update</a>( &amp;comp, data+offset, len ); <span class="comment">/* обновляем внутреннее состояние */</span></div><div class="line">    offset += len;</div><div class="line">  }</div><div class="line">  <a class="code" href="ak__compress_8c.html#ae83443579230980fed2cfc3c2bec0488">ak_compress_finalize</a>( &amp;comp, NULL, 0, out2 ); <span class="comment">/* получаем окончательное значение */</span></div><div class="line">  printf(<span class="stringliteral">&quot;hash: %s\n&quot;</span>, str = <a class="code" href="ak__tools_8c.html#a2975dac532a6f245813cde9a2d3a9909">ak_ptr_to_hexstr</a>( out2, 32, <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a872df325c5f9fac16ef66c17c1666908">ak_false</a> )); free( str );</div><div class="line"></div><div class="line">  <a class="code" href="ak__compress_8c.html#ae83443579230980fed2cfc3c2bec0488">ak_compress_finalize</a>( &amp;comp, NULL, 0, out2 ); <span class="comment">/* получаем окончательное значение второй раз */</span></div><div class="line">  printf(<span class="stringliteral">&quot;hash: %s\n&quot;</span>, str = <a class="code" href="ak__tools_8c.html#a2975dac532a6f245813cde9a2d3a9909">ak_ptr_to_hexstr</a>( out2, 32, <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a872df325c5f9fac16ef66c17c1666908">ak_false</a> )); free( str );</div><div class="line"></div><div class="line">  <a class="code" href="ak__compress_8c.html#ae83443579230980fed2cfc3c2bec0488">ak_compress_finalize</a>( &amp;comp, NULL, 0, out2 ); <span class="comment">/* получаем окончательное значение третий раз */</span></div><div class="line">  printf(<span class="stringliteral">&quot;hash: %s\n&quot;</span>, str = <a class="code" href="ak__tools_8c.html#a2975dac532a6f245813cde9a2d3a9909">ak_ptr_to_hexstr</a>( out2, 32, <a class="code" href="libakrypt_8h.html#a8d5ecbffb7fc8e1aa60754ae866eb486a872df325c5f9fac16ef66c17c1666908">ak_false</a> )); free( str );</div><div class="line"></div><div class="line"> <span class="comment">/* очищаем объекты */</span></div><div class="line">  <a class="code" href="ak__compress_8c.html#a1a2220fdaff8ccc3661a9e5d067cc02f">ak_compress_destroy</a>( &amp;comp );</div><div class="line">  <a class="code" href="ak__hash_8c.html#aea4a84bb72d71f441657796db70a0d99">ak_hash_destroy</a>( &amp;<a class="code" href="structcompress.html#a38b0408fc77ca676c794ef9ef33622fa">ctx</a> );</div><div class="line"></div><div class="line"> <span class="comment">/* проверяем, что результаты двух разных вычислений совпали */</span></div><div class="line">  <span class="keywordflow">if</span>( !<a class="code" href="ak__tools_8c.html#aad0f57a8872509185b031a4dca334f98">ak_ptr_is_equal</a>( out, out2, 32 )) result = <a class="code" href="libakrypt_8h.html#ad069bfba9bc6325246fd639d86dd8e51">ak_error_not_equal_data</a>;</div><div class="line"></div><div class="line"> <span class="comment">/* останавливаем библиотеку и возвращаем результат сравнения */</span></div><div class="line">  <a class="code" href="ak__libakrypt_8c.html#a7b2010bf04cdfa2e9575dbe570de71cb">ak_libakrypt_destroy</a>();</div><div class="line"> <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="guide_glossary"></a>
Приложение А. Терминология и принятые обозначения</h1>
<ul>
<li><b>Класс</b> (class) - структура, определенная через определитель typedef и содержащая в себе как данные, так и указатели на функции, обрабатывающие данные, хранящиеся в структуре. Один класс может соответствовать как одному, так и нескольким однотипным криптографическим механизмам, допускающим схожую программную реализацию.</li>
<li><b>Объект</b> (object) - экземпляр класса, однозначно связанный с конкретным криптографическим механизмом.</li>
<li><b>Контекст</b> (context) - указатель на объект (экземпляр заданного класса). Контекст может быть определен только в случае, когда существует связанный с ним объект. В противном случае контекст обязан принимать значение NULL.</li>
<li><b>Дескриптор</b> (handle) - натуральное число, являющееся идентификатором конкретного объекта или его контекста, и обеспечивающее доступ к объекту.</li>
<li><b>Производящая</b> <b>функция</b> - реализованная в библиотеке функция, создающая объекты заданного класса.</li>
</ul>
<h1><a class="anchor" id="guide_names"></a>
Приложение Б. Принципы наименования функций библиотеки.</h1>
<p>Для всех функций библиотеки принят единый принцип наименования. Имя функции строится следующим образом</p>
<div class="fragment"><div class="line">ak_класс_действие</div><div class="line">ak_класс_действие_объект</div><div class="line">ak_класс_действие_предлог_действие2</div></div><!-- fragment --><p>где</p>
<ul>
<li><code>ak</code> - префикс библиотеки, </li>
<li><code>класс</code> - класс, над объектами которого производятся заданные действия, </li>
<li><code>действие</code> - основное действие над объектом, </li>
<li><code>действие2</code> - следующее действие над объектом, </li>
<li><code>предлог</code> - направление действия, </li>
<li><code>объект</code> - объект, на который направлено действие, либо объект, являющийся параметром действия.</li>
</ul>
<h2><a class="anchor" id="guide_names_rules"></a>
Основные действия</h2>
<p>При выборе имен функций использовались следующие основные действия.</p>
<ul>
<li><code>create</code> - действие, которое реализует конструктор (инициализацию) объекта, под который уже выделена память - статическая или динамическая. </li>
<li><code>new</code> - действие, которое выделяет динамическую память под объект, а после его инициализирует с помощью действия <code>create</code>; фактически, это конструктор, возвращающий указатель на созданный объект.</li>
</ul>
<ul>
<li><code>destroy</code> - действие, которое уничтожает поля существующего объекта; память, выделенная под объект, не освобождается. </li>
<li><code>delete</code> - действие, которое позволяет сначала уничтожить поля существующего объекта (с помощью действия <code>destroy</code>), а потом и выделенную под объект память. </li>
<li><code>set</code> - присвоить объекту некоторое значение. </li>
<li><code>get</code> - получить характеристику объекта (значение некоторого поля) без ее изменения, как правило данное действие возвращает копию значения, хранящегося в объекте.</li>
</ul>
<h2><a class="anchor" id="guide_names_to"></a>
Предлоги</h2>
<ul>
<li><code>to</code> - действие направлено от объекта к объекту2 (в большинстве случаем использование предлога to означает процедуру преобразования объекта, в результате которой создается новый объект, удаление которого, как правило, возлагается на пользователя биьлиотеки). </li>
<li><code>from</code> - действие направлено к объекту от объекта2 (в большинстве случаев функция реализует операцию присвоения нового значения объекту) </li>
<li><code>and</code> - предлог для связи нескольких действий над объектом</li>
</ul>
<h2><a class="anchor" id="guide_names_order"></a>
Порядок следования аргументов функции</h2>
<ul>
<li><code>арг1</code> - первый аргумент это объект, с которым выполняется указанное действие (во всех арифметических функциях - являющийся результатом действия) </li>
<li><code>арг2</code>, ... - объекты, участвующие в действии </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Документация по libakrypt. Последние изменения: Вс 23 Сен 2018 21:13:42. Создано системой
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
